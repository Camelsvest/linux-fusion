diff -Naur linux-2.4.20-rc1/drivers/char/Config.in linux-2.4.20-rc1-fusion/drivers/char/Config.in
--- linux-2.4.20-rc1/drivers/char/Config.in	2002-11-01 13:32:31.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/Config.in	2002-11-02 03:11:39.000000000 +0100
@@ -228,6 +228,7 @@
    dep_tristate 'Intel i8x0 Random Number Generator support' CONFIG_INTEL_RNG $CONFIG_PCI
 fi
 tristate '/dev/nvram support' CONFIG_NVRAM
+tristate 'Fusion Kernel Device' CONFIG_FUSION_DEVICE
 tristate 'Enhanced Real Time Clock Support' CONFIG_RTC
 if [ "$CONFIG_IA64" = "y" ]; then
    bool 'EFI Real Time Clock Services' CONFIG_EFI_RTC
diff -Naur linux-2.4.20-rc1/drivers/char/Makefile linux-2.4.20-rc1-fusion/drivers/char/Makefile
--- linux-2.4.20-rc1/drivers/char/Makefile	2002-11-01 13:32:31.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/Makefile	2002-11-02 03:11:39.000000000 +0100
@@ -268,6 +268,9 @@
   obj-y += mwave/mwave.o
 endif
 
+subdir-$(CONFIG_FUSION_DEVICE) += fusion
+
+
 include $(TOPDIR)/Rules.make
 
 fastdep:
diff -Naur linux-2.4.20-rc1/drivers/char/fusion/Makefile linux-2.4.20-rc1-fusion/drivers/char/fusion/Makefile
--- linux-2.4.20-rc1/drivers/char/fusion/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/fusion/Makefile	2002-11-02 02:38:50.000000000 +0100
@@ -0,0 +1,6 @@
+O_TARGET := fusion.o
+
+obj-y   := fusiondev.o fusionee.o list.o ref.o skirmish.o
+obj-m   := $(O_TARGET)
+
+include $(TOPDIR)/Rules.make
diff -Naur linux-2.4.20-rc1/drivers/char/fusion/fusiondev.c linux-2.4.20-rc1-fusion/drivers/char/fusion/fusiondev.c
--- linux-2.4.20-rc1/drivers/char/fusion/fusiondev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/fusion/fusiondev.c	2002-11-02 02:38:50.000000000 +0100
@@ -0,0 +1,238 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  convergence integrated media GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "ref.h"
+#include "skirmish.h"
+
+#define DEBUG(x...)  printk (KERN_DEBUG "Fusion: " x)
+
+MODULE_LICENSE("GPL");
+
+struct proc_dir_entry *proc_fusion_dir;
+
+/******************************************************************************/
+
+static int
+fusion_open (struct inode *inode, struct file *file)
+{
+  int ret;
+  int fusion_id;
+
+  ret = fusionee_new (&fusion_id);
+  if (ret)
+    return ret;
+
+  file->private_data = (void*) fusion_id;
+
+  return 0;
+}
+
+static int
+fusion_release (struct inode *inode, struct file *file)
+{
+  int fusion_id = (int) file->private_data;
+
+  fusionee_destroy (fusion_id);
+
+  return 0;
+}
+
+static int
+fusion_ioctl (struct inode *inode, struct file *file,
+              unsigned int cmd, unsigned long arg)
+{
+  int id;
+  int ret;
+  int refs;
+  int fusion_id = (int) file->private_data;
+
+  switch (cmd)
+    {
+    case FUSION_GET_ID:
+      put_user (fusion_id, (int*) arg);
+      break;
+
+    case FUSION_REF_NEW:
+      ret = fusion_ref_new (&id);
+      if (ret)
+        return ret;
+
+      put_user (id, (int*) arg);
+      break;
+
+    case FUSION_REF_UP:
+      get_user (id, (int*) arg);
+
+      return fusion_ref_up (id, fusion_id);
+
+    case FUSION_REF_UP_GLOBAL:
+      get_user (id, (int*) arg);
+
+      return fusion_ref_up (id, 0);
+
+    case FUSION_REF_DOWN:
+      get_user (id, (int*) arg);
+
+      return fusion_ref_down (id, fusion_id);
+
+    case FUSION_REF_DOWN_GLOBAL:
+      get_user (id, (int*) arg);
+
+      return fusion_ref_down (id, 0);
+
+    case FUSION_REF_ZERO_LOCK:
+      get_user (id, (int*) arg);
+
+      return fusion_ref_zero_lock (id);
+
+    case FUSION_REF_ZERO_TRYLOCK:
+      get_user (id, (int*) arg);
+
+      return fusion_ref_zero_trylock (id);
+
+    case FUSION_REF_UNLOCK:
+      get_user (id, (int*) arg);
+
+      return fusion_ref_unlock (id);
+
+    case FUSION_REF_STAT:
+      get_user (id, (int*) arg);
+
+      ret = fusion_ref_stat (id, &refs);
+      if (ret)
+        return ret;
+
+      return refs;
+
+    case FUSION_REF_DESTROY:
+      get_user (id, (int*) arg);
+
+      return fusion_ref_destroy (id);
+
+    case FUSION_SKIRMISH_NEW:
+      ret = fusion_skirmish_new (&id);
+      if (ret)
+        return ret;
+
+      put_user (id, (int*) arg);
+      break;
+
+    case FUSION_SKIRMISH_PREVAIL:
+      get_user (id, (int*) arg);
+
+      return fusion_skirmish_prevail (id, fusion_id);
+
+    case FUSION_SKIRMISH_SWOOP:
+      get_user (id, (int*) arg);
+
+      return fusion_skirmish_swoop (id, fusion_id);
+
+    case FUSION_SKIRMISH_DISMISS:
+      get_user (id, (int*) arg);
+
+      return fusion_skirmish_dismiss (id, fusion_id);
+
+    case FUSION_SKIRMISH_DESTROY:
+      get_user (id, (int*) arg);
+
+      return fusion_skirmish_destroy (id);
+
+    default:
+      return -ENOTTY;
+    }
+
+  return 0;
+}
+
+static struct file_operations fusion_fops = {
+  .owner   = THIS_MODULE,
+  .ioctl   = fusion_ioctl,
+  .open    = fusion_open,
+  .release = fusion_release,
+};
+
+static struct miscdevice fusion_miscdev = {
+  .minor   = FUSION_MINOR,
+  .name    = "fusion",
+  .fops    = &fusion_fops,
+};
+
+/******************************************************************************/
+
+static int __init
+fusion_init(void)
+{
+  int ret;
+
+  proc_fusion_dir = proc_mkdir ("fusion", NULL);
+
+  ret = fusionee_init();
+  if (ret)
+    goto error_fusionee;
+
+  ret = fusion_ref_init();
+  if (ret)
+    goto error_ref;
+
+  ret = fusion_skirmish_init();
+  if (ret)
+    goto error_skirmish;
+
+  ret = misc_register (&fusion_miscdev);
+  if (ret)
+    goto error_misc;
+
+  return 0;
+
+
+ error_misc:
+  fusion_skirmish_cleanup();
+
+ error_skirmish:
+  fusion_ref_cleanup();
+
+ error_ref:
+  fusionee_cleanup();
+
+ error_fusionee:
+  return ret;
+}
+
+static void __exit
+fusion_exit(void)
+{
+  misc_deregister (&fusion_miscdev);
+  
+  fusion_skirmish_cleanup();
+  fusion_ref_cleanup();
+  fusionee_cleanup();
+}
+
+module_init(fusion_init);
+module_exit(fusion_exit);
diff -Naur linux-2.4.20-rc1/drivers/char/fusion/fusiondev.h linux-2.4.20-rc1-fusion/drivers/char/fusion/fusiondev.h
--- linux-2.4.20-rc1/drivers/char/fusion/fusiondev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/fusion/fusiondev.h	2002-10-28 18:04:55.000000000 +0100
@@ -0,0 +1,22 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  convergence integrated media GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSIONDEV_H__
+#define __FUSIONDEV_H__
+
+#include <linux/proc_fs.h>
+
+extern struct proc_dir_entry *proc_fusion_dir;
+
+#endif
diff -Naur linux-2.4.20-rc1/drivers/char/fusion/fusionee.c linux-2.4.20-rc1-fusion/drivers/char/fusion/fusionee.c
--- linux-2.4.20-rc1/drivers/char/fusion/fusionee.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/fusion/fusionee.c	2002-11-02 02:38:50.000000000 +0100
@@ -0,0 +1,213 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  convergence integrated media GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+
+#include <linux/fusion.h>
+
+#include "list.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "ref.h"
+#include "skirmish.h"
+
+
+typedef struct {
+  FusionLink link;
+
+  spinlock_t lock;
+
+  int        id;
+  int        pid;
+} Fusionee;
+
+
+/******************************************************************************/
+
+static Fusionee *lookup_fusionee (int id);
+
+static Fusionee *lock_fusionee   (int id);
+static void      unlock_fusionee (Fusionee *fusionee);
+
+/******************************************************************************/
+
+static int         ids            = 1;
+static FusionLink *fusionees      = NULL;
+static spinlock_t  fusionees_lock = SPIN_LOCK_UNLOCKED;
+
+/******************************************************************************/
+
+static int
+fusionees_read_proc(char *buf, char **start, off_t offset,
+                    int len, int *eof, void *private)
+{
+  FusionLink *l;
+  int written = 0;
+
+  spin_lock (&fusionees_lock);
+
+  fusion_list_foreach (l, fusionees)
+    {
+      Fusionee *fusionee = (Fusionee*) l;
+
+      written += sprintf(buf+written, "(%5d) 0x%08x\n",
+                         fusionee->pid, fusionee->id);
+      if (written < offset)
+        {
+          offset -= written;
+          written = 0;
+        }
+
+      if (written >= len)
+        break;
+    }
+
+  spin_unlock (&fusionees_lock);
+
+  *start = buf + offset;
+  written -= offset;
+  if(written > len)
+    {
+      *eof = 0;
+      return len;
+    }
+
+  *eof = 1;
+  return (written<0) ? 0 : written;
+}
+
+int
+fusionee_init()
+{
+  create_proc_read_entry("fusionees", 0, proc_fusion_dir,
+                         fusionees_read_proc, NULL);
+
+  return 0;
+}
+
+void
+fusionee_cleanup()
+{
+  FusionLink *l = fusionees;
+
+  while (l)
+    {
+      FusionLink *next     = l->next;
+      Fusionee   *fusionee = (Fusionee *) l;
+
+      kfree (fusionee);
+
+      l = next;
+    }
+
+  fusionees = NULL;
+
+  remove_proc_entry ("fusionees", proc_fusion_dir);
+}
+
+/******************************************************************************/
+
+int
+fusionee_new (int *id)
+{
+  Fusionee *fusionee;
+
+  fusionee = kmalloc (sizeof(Fusionee), GFP_KERNEL);
+  if (!fusionee)
+    return -ENOMEM;
+
+  memset (fusionee, 0, sizeof(Fusionee));
+
+  spin_lock (&fusionees_lock);
+
+  fusionee->id   = ids++;
+  fusionee->pid  = current->pid;
+  fusionee->lock = SPIN_LOCK_UNLOCKED;
+
+  fusion_list_prepend (&fusionees, &fusionee->link);
+
+  spin_unlock (&fusionees_lock);
+
+  *id = fusionee->id;
+
+  return 0;
+}
+
+int
+fusionee_destroy (int id)
+{
+  Fusionee *fusionee = lookup_fusionee (id);
+
+  if (!fusionee)
+    return -EINVAL;
+
+  spin_lock (&fusionee->lock);
+
+  fusion_list_remove (&fusionees, &fusionee->link);
+
+  fusion_skirmish_dismiss_all (id);
+  fusion_ref_clear_all_local (id);
+
+  spin_unlock (&fusionees_lock);
+
+  kfree (fusionee);
+
+  return 0;
+}
+
+/******************************************************************************/
+
+static Fusionee *
+lookup_fusionee (int id)
+{
+  FusionLink *l;
+
+  spin_lock (&fusionees_lock);
+
+  fusion_list_foreach (l, fusionees)
+    {
+      Fusionee *fusionee = (Fusionee *) l;
+
+      if (fusionee->id == id)
+        return fusionee;
+    }
+
+  spin_unlock (&fusionees_lock);
+
+  return NULL;
+}
+
+static Fusionee *
+lock_fusionee (int id)
+{
+  Fusionee *fusionee = lookup_fusionee (id);
+
+  if (fusionee)
+    {
+      spin_lock (&fusionee->lock);
+      spin_unlock (&fusionees_lock);
+    }
+
+  return fusionee;
+}
+
+static void
+unlock_fusionee (Fusionee *fusionee)
+{
+  spin_unlock (&fusionee->lock);
+}
diff -Naur linux-2.4.20-rc1/drivers/char/fusion/fusionee.h linux-2.4.20-rc1-fusion/drivers/char/fusion/fusionee.h
--- linux-2.4.20-rc1/drivers/char/fusion/fusionee.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/fusion/fusionee.h	2002-11-02 00:06:43.000000000 +0100
@@ -0,0 +1,34 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  convergence integrated media GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSIONEE_H__
+#define __FUSIONEE_H__
+
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusionee_init (void);
+void fusionee_cleanup (void);
+
+
+/* internal functions */
+
+int fusionee_new (int *id);
+int fusionee_destroy (int id);
+
+
+
+#endif
diff -Naur linux-2.4.20-rc1/drivers/char/fusion/list.c linux-2.4.20-rc1-fusion/drivers/char/fusion/list.c
--- linux-2.4.20-rc1/drivers/char/fusion/list.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/fusion/list.c	2002-10-16 14:25:49.000000000 +0200
@@ -0,0 +1,43 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  convergence integrated media GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/types.h>
+
+#include "list.h"
+
+void
+fusion_list_prepend (FusionLink **list, FusionLink *link)
+{
+     link->prev = NULL;
+     link->next = *list;
+
+     if (*list)
+          (*list)->prev = link;
+
+     *list = link;
+}
+
+void
+fusion_list_remove (FusionLink **list, FusionLink *link)
+{
+     if (link->prev)
+          link->prev->next = link->next;
+     else
+          *list = link->next;
+
+     if (link->next)
+          link->next->prev = link->prev;
+
+     link->next = link->prev = NULL;
+}
diff -Naur linux-2.4.20-rc1/drivers/char/fusion/list.h linux-2.4.20-rc1-fusion/drivers/char/fusion/list.h
--- linux-2.4.20-rc1/drivers/char/fusion/list.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/fusion/list.h	2002-11-02 00:06:43.000000000 +0100
@@ -0,0 +1,32 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  convergence integrated media GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__LIST_H__
+#define __FUSION__LIST_H__
+
+#include "types.h"
+
+
+typedef struct _FusionLink {
+  struct _FusionLink *next;
+  struct _FusionLink *prev;
+} FusionLink;
+
+void fusion_list_prepend (FusionLink **list, FusionLink *link);
+void fusion_list_remove  (FusionLink **list, FusionLink *link);
+
+#define fusion_list_foreach(link, list)  for (link = list; link; link = link->next)
+
+#endif /* __FUSION__LIST_H__ */
+
diff -Naur linux-2.4.20-rc1/drivers/char/fusion/ref.c linux-2.4.20-rc1-fusion/drivers/char/fusion/ref.c
--- linux-2.4.20-rc1/drivers/char/fusion/ref.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/fusion/ref.c	2002-11-02 00:06:43.000000000 +0100
@@ -0,0 +1,503 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  convergence integrated media GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "ref.h"
+
+typedef struct {
+  FusionLink  link;
+  int         fusion_id;
+  int         refs;
+} LocalRef;
+
+typedef struct {
+  FusionLink         link;
+
+  spinlock_t         lock;
+
+  int                id;
+  int                pid;
+
+  int                global;
+  int                local;
+
+  bool               locked;
+
+  FusionLink        *local_refs;
+
+  wait_queue_head_t  wait;
+} FusionRef;
+
+/******************************************************************************/
+
+static FusionRef *lookup_ref     (int id);
+
+static FusionRef *lock_ref       (int id);
+static void       unlock_ref     (FusionRef *ref);
+
+static int        add_local      (FusionRef *ref, int fusion_id, int add);
+static void       clear_local    (FusionRef *ref, int fusion_id);
+static void       free_all_local (FusionRef *ref);
+
+/******************************************************************************/
+
+static int         ids       = 0;
+static FusionLink *refs      = NULL;
+static spinlock_t  refs_lock = SPIN_LOCK_UNLOCKED;
+
+/******************************************************************************/
+
+static int
+fusion_ref_read_proc(char *buf, char **start, off_t offset,
+                     int len, int *eof, void *private)
+{
+  FusionLink *l;
+  int written = 0;
+
+  spin_lock (&refs_lock);
+
+  fusion_list_foreach (l, refs)
+    {
+      FusionRef *ref = (FusionRef*) l;
+
+      written += sprintf(buf+written, "(%5d) 0x%08x %2d %2d %s\n",
+                         ref->pid, ref->id, ref->global, ref->local,
+                         ref->locked ? "(locked)" : "");
+      if (written < offset)
+        {
+          offset -= written;
+          written = 0;
+        }
+
+      if (written >= len)
+        break;
+    }
+
+  spin_unlock (&refs_lock);
+
+  *start = buf + offset;
+  written -= offset;
+  if(written > len)
+    {
+      *eof = 0;
+      return len;
+    }
+
+  *eof = 1;
+  return (written<0) ? 0 : written;
+}
+
+int
+fusion_ref_init()
+{
+  create_proc_read_entry("refs", 0, proc_fusion_dir,
+                         fusion_ref_read_proc, NULL);
+
+  return 0;
+}
+
+void
+fusion_ref_cleanup()
+{
+  FusionLink *l = refs;
+
+  while (l)
+    {
+      FusionLink *next = l->next;
+      FusionRef  *ref  = (FusionRef *) l;
+
+      free_all_local (ref);
+
+      kfree (ref);
+
+      l = next;
+    }
+
+  refs = NULL;
+
+  remove_proc_entry ("refs", proc_fusion_dir);
+}
+
+/******************************************************************************/
+
+int
+fusion_ref_new (int *id)
+{
+  FusionRef *ref;
+
+  ref = kmalloc (sizeof(FusionRef), GFP_KERNEL);
+  if (!ref)
+    return -ENOMEM;
+
+  memset (ref, 0, sizeof(FusionRef));
+
+  spin_lock (&refs_lock);
+
+  ref->id   = ids++;
+  ref->pid  = current->pid;
+  ref->lock = SPIN_LOCK_UNLOCKED;
+
+  init_waitqueue_head (&ref->wait);
+
+  fusion_list_prepend (&refs, &ref->link);
+
+  spin_unlock (&refs_lock);
+
+  *id = ref->id;
+
+  return 0;
+}
+
+int
+fusion_ref_up (int id, int fusion_id)
+{
+  FusionRef *ref = lock_ref (id);
+
+  if (!ref)
+    return -EINVAL;
+
+  if (ref->locked)
+    {
+      unlock_ref (ref);
+      return -EAGAIN;
+    }
+
+  if (fusion_id)
+    {
+      int ret;
+
+      ret = add_local (ref, fusion_id, 1);
+      if (ret)
+        {
+          unlock_ref (ref);
+          return ret;
+        }
+
+      ref->local++;
+    }
+  else
+    ref->global++;
+
+  unlock_ref (ref);
+
+  return 0;
+}
+
+int
+fusion_ref_down (int id, int fusion_id)
+{
+  FusionRef *ref = lock_ref (id);
+
+  if (!ref)
+    return -EINVAL;
+
+  if (ref->locked)
+    {
+      unlock_ref (ref);
+      return -EAGAIN;
+    }
+
+  if (fusion_id)
+    {
+      int ret;
+
+      if (!ref->local)
+        return -EIO;
+
+      ret = add_local (ref, fusion_id, -1);
+      if (ret)
+        {
+          unlock_ref (ref);
+          return ret;
+        }
+
+      ref->local--;
+    }
+  else
+    {
+      if (!ref->global)
+        return -EIO;
+
+      ref->global--;
+    }
+
+  if (ref->local + ref->global == 0)
+    wake_up_interruptible_all (&ref->wait);
+
+  unlock_ref (ref);
+
+  return 0;
+}
+
+int
+fusion_ref_zero_lock (int id)
+{
+  FusionRef *ref;
+
+  while (true)
+    {
+      ref = lock_ref (id);
+      if (!ref)
+        return -EINVAL;
+
+      if (ref->locked)
+        {
+          unlock_ref (ref);
+          return -EAGAIN;
+        }
+
+      if (ref->global || ref->local)
+        {
+          unlock_ref (ref);
+
+          interruptible_sleep_on (&ref->wait);
+
+          if (signal_pending(current))
+            return -ERESTARTSYS;
+        }
+      else
+        break;
+    }
+
+  ref->locked = true;
+
+  unlock_ref (ref);
+
+  return 0;
+}
+
+int
+fusion_ref_zero_trylock (int id)
+{
+  int        ret = 0;
+  FusionRef *ref = lock_ref (id);
+
+  if (!ref)
+    return -EINVAL;
+
+  if (ref->locked)
+    {
+      unlock_ref (ref);
+      return -EAGAIN;
+    }
+
+  if (ref->global || ref->local)
+    ret = -ETOOMANYREFS;
+  else
+    ref->locked = true;
+
+  unlock_ref (ref);
+
+  return ret;
+}
+
+int
+fusion_ref_unlock (int id)
+{
+  FusionRef *ref = lock_ref (id);
+
+  if (!ref)
+    return -EINVAL;
+
+  ref->locked = false;
+
+  unlock_ref (ref);
+
+  return 0;
+}
+
+int
+fusion_ref_stat (int id, int *refs)
+{
+  FusionRef *ref = lock_ref (id);
+
+  if (!ref)
+    return -EINVAL;
+
+  *refs = ref->global + ref->local;
+
+  unlock_ref (ref);
+
+  return 0;
+}
+
+int
+fusion_ref_destroy (int id)
+{
+  FusionRef *ref = lookup_ref (id);
+
+  if (!ref)
+    return -EINVAL;
+
+  spin_lock (&ref->lock);
+
+  fusion_list_remove (&refs, &ref->link);
+
+  wake_up_interruptible_all (&ref->wait);
+
+  spin_unlock (&refs_lock);
+
+  free_all_local (ref);
+
+  kfree (ref);
+
+  return 0;
+}
+
+void
+fusion_ref_clear_all_local (int fusion_id)
+{
+  FusionLink *l;
+
+  spin_lock (&refs_lock);
+
+  fusion_list_foreach (l, refs)
+    {
+      FusionRef *ref = (FusionRef *) l;
+
+      clear_local (ref, fusion_id);
+    }
+
+  spin_unlock (&refs_lock);
+}
+
+/******************************************************************************/
+
+static FusionRef *
+lookup_ref (int id)
+{
+  FusionLink *l;
+
+  spin_lock (&refs_lock);
+
+  fusion_list_foreach (l, refs)
+    {
+      FusionRef *ref = (FusionRef *) l;
+
+      if (ref->id == id)
+        return ref;
+    }
+
+  spin_unlock (&refs_lock);
+
+  return NULL;
+}
+
+static FusionRef *
+lock_ref (int id)
+{
+  FusionRef *ref = lookup_ref (id);
+
+  if (ref)
+    {
+      spin_lock (&ref->lock);
+      spin_unlock (&refs_lock);
+    }
+
+  return ref;
+}
+
+static void
+unlock_ref (FusionRef *ref)
+{
+  spin_unlock (&ref->lock);
+}
+
+static int
+add_local (FusionRef *ref, int fusion_id, int add)
+{
+  FusionLink *l;
+  LocalRef   *local;
+
+  fusion_list_foreach (l, ref->local_refs)
+    {
+      local = (LocalRef *) l;
+
+      if (local->fusion_id == fusion_id)
+        {
+          if (local->refs + add < 0)
+            return -EIO;
+
+          local->refs += add;
+          return 0;
+        }
+    }
+
+  local = kmalloc (sizeof(LocalRef), GFP_KERNEL);
+  if (!local)
+    return -ENOMEM;
+
+  local->fusion_id = fusion_id;
+  local->refs      = add;
+
+  fusion_list_prepend (&ref->local_refs, &local->link);
+
+  return 0;
+}
+
+static void
+clear_local (FusionRef *ref, int fusion_id)
+{
+  FusionLink *l;
+
+  spin_lock (&ref->lock);
+
+  fusion_list_foreach (l, ref->local_refs)
+    {
+      LocalRef *local = (LocalRef *) l;
+
+      if (local->fusion_id == fusion_id)
+        {
+          ref->local -= local->refs;
+
+          if (ref->local + ref->global == 0)
+            wake_up_interruptible_all (&ref->wait);
+
+          break;
+        }
+    }
+
+  if (l)
+    fusion_list_remove (&ref->local_refs, l);
+
+  spin_unlock (&ref->lock);
+}
+
+static void
+free_all_local (FusionRef *ref)
+{
+  FusionLink *l = ref->local_refs;
+
+  while (l)
+    {
+      FusionLink *next = l->next;
+
+      kfree (l);
+
+      l = next;
+    }
+
+  ref->local_refs = NULL;
+}
diff -Naur linux-2.4.20-rc1/drivers/char/fusion/ref.h linux-2.4.20-rc1-fusion/drivers/char/fusion/ref.h
--- linux-2.4.20-rc1/drivers/char/fusion/ref.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/fusion/ref.h	2002-11-02 00:06:43.000000000 +0100
@@ -0,0 +1,43 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  convergence integrated media GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__REF_H__
+#define __FUSION__REF_H__
+
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_ref_init (void);
+void fusion_ref_cleanup (void);
+
+
+/* public API */
+
+int fusion_ref_new (int *id);
+int fusion_ref_up (int id, int fusion_id);
+int fusion_ref_down (int id, int fusion_id);
+int fusion_ref_zero_lock (int id);
+int fusion_ref_zero_trylock (int id);
+int fusion_ref_unlock (int id);
+int fusion_ref_stat (int id, int *refs);
+int fusion_ref_destroy (int id);
+
+
+/* internal functions */
+
+void fusion_ref_clear_all_local (int fusion_id);
+
+#endif
diff -Naur linux-2.4.20-rc1/drivers/char/fusion/skirmish.c linux-2.4.20-rc1-fusion/drivers/char/fusion/skirmish.c
--- linux-2.4.20-rc1/drivers/char/fusion/skirmish.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/fusion/skirmish.c	2002-11-02 02:28:29.000000000 +0100
@@ -0,0 +1,318 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  convergence integrated media GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "skirmish.h"
+
+typedef struct {
+  FusionLink         link;
+
+  spinlock_t         lock;
+
+  int                id;
+  int                pid;
+
+  int                fusion_id;  /* non-zero if locked */
+
+  wait_queue_head_t  wait;
+} FusionSkirmish;
+
+/******************************************************************************/
+
+static FusionSkirmish *lookup_skirmish     (int id);
+
+static FusionSkirmish *lock_skirmish       (int id);
+static void            unlock_skirmish     (FusionSkirmish *skirmish);
+
+/******************************************************************************/
+
+static int         ids            = 0;
+static FusionLink *skirmishs      = NULL;
+static spinlock_t  skirmishs_lock = SPIN_LOCK_UNLOCKED;
+
+/******************************************************************************/
+
+static int
+fusion_skirmish_read_proc(char *buf, char **start, off_t offset,
+                     int len, int *eof, void *private)
+{
+  FusionLink *l;
+  int written = 0;
+
+  spin_lock (&skirmishs_lock);
+
+  fusion_list_foreach (l, skirmishs)
+    {
+      FusionSkirmish *skirmish = (FusionSkirmish*) l;
+
+      written += sprintf(buf+written, "(%5d) 0x%08x %s\n",
+                         skirmish->pid, skirmish->id,
+                         skirmish->fusion_id ? "(locked)" : "");
+      if (written < offset)
+        {
+          offset -= written;
+          written = 0;
+        }
+
+      if (written >= len)
+        break;
+    }
+
+  spin_unlock (&skirmishs_lock);
+
+  *start = buf + offset;
+  written -= offset;
+  if(written > len)
+    {
+      *eof = 0;
+      return len;
+    }
+
+  *eof = 1;
+  return (written<0) ? 0 : written;
+}
+
+int
+fusion_skirmish_init()
+{
+  create_proc_read_entry("skirmishs", 0, proc_fusion_dir,
+                         fusion_skirmish_read_proc, NULL);
+
+  return 0;
+}
+
+void
+fusion_skirmish_cleanup()
+{
+  FusionLink *l = skirmishs;
+
+  while (l)
+    {
+      FusionLink     *next     = l->next;
+      FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+      kfree (skirmish);
+
+      l = next;
+    }
+
+  skirmishs = NULL;
+
+  remove_proc_entry ("skirmishs", proc_fusion_dir);
+}
+
+/******************************************************************************/
+
+int
+fusion_skirmish_new (int *id)
+{
+  FusionSkirmish *skirmish;
+
+  skirmish = kmalloc (sizeof(FusionSkirmish), GFP_KERNEL);
+  if (!skirmish)
+    return -ENOMEM;
+
+  memset (skirmish, 0, sizeof(FusionSkirmish));
+
+  spin_lock (&skirmishs_lock);
+
+  skirmish->id   = ids++;
+  skirmish->pid  = current->pid;
+  skirmish->lock = SPIN_LOCK_UNLOCKED;
+
+  init_waitqueue_head (&skirmish->wait);
+
+  fusion_list_prepend (&skirmishs, &skirmish->link);
+
+  spin_unlock (&skirmishs_lock);
+
+  *id = skirmish->id;
+
+  return 0;
+}
+
+int
+fusion_skirmish_prevail (int id, int fusion_id)
+{
+  FusionSkirmish *skirmish;
+
+  while (true)
+    {
+      skirmish = lock_skirmish (id);
+      if (!skirmish)
+        return -EINVAL;
+
+      if (skirmish->fusion_id)
+        {
+          unlock_skirmish (skirmish);
+
+          interruptible_sleep_on (&skirmish->wait);
+
+          if (signal_pending(current))
+            return -ERESTARTSYS;
+        }
+      else
+        break;
+    }
+
+  skirmish->fusion_id = fusion_id;
+
+  unlock_skirmish (skirmish);
+
+  return 0;
+}
+
+int
+fusion_skirmish_swoop (int id, int fusion_id)
+{
+  FusionSkirmish *skirmish = lock_skirmish (id);
+
+  if (!skirmish)
+    return -EINVAL;
+
+  if (skirmish->fusion_id)
+    {
+      unlock_skirmish (skirmish);
+      return -EAGAIN;
+    }
+
+  skirmish->fusion_id = fusion_id;
+
+  unlock_skirmish (skirmish);
+
+  return 0;
+}
+
+int
+fusion_skirmish_dismiss (int id, int fusion_id)
+{
+  FusionSkirmish *skirmish = lock_skirmish (id);
+
+  if (!skirmish)
+    return -EINVAL;
+
+  if (skirmish->fusion_id != fusion_id)
+    {
+      unlock_skirmish (skirmish);
+      return -EIO;
+    }
+
+  skirmish->fusion_id = 0;
+
+  wake_up_interruptible_all (&skirmish->wait);
+
+  unlock_skirmish (skirmish);
+
+  return 0;
+}
+
+int
+fusion_skirmish_destroy (int id)
+{
+  FusionSkirmish *skirmish = lookup_skirmish (id);
+
+  if (!skirmish)
+    return -EINVAL;
+
+  spin_lock (&skirmish->lock);
+
+  fusion_list_remove (&skirmishs, &skirmish->link);
+
+  wake_up_interruptible_all (&skirmish->wait);
+
+  spin_unlock (&skirmishs_lock);
+
+  kfree (skirmish);
+
+  return 0;
+}
+
+void
+fusion_skirmish_dismiss_all (int fusion_id)
+{
+  FusionLink *l;
+
+  spin_lock (&skirmishs_lock);
+
+  fusion_list_foreach (l, skirmishs)
+    {
+      FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+      spin_lock (&skirmish->lock);
+
+      if (skirmish->fusion_id == fusion_id)
+        {
+          skirmish->fusion_id = 0;
+
+          wake_up_interruptible_all (&skirmish->wait);
+        }
+
+      spin_unlock (&skirmish->lock);
+    }
+
+  spin_unlock (&skirmishs_lock);
+}
+
+/******************************************************************************/
+
+static FusionSkirmish *
+lookup_skirmish (int id)
+{
+  FusionLink *l;
+
+  spin_lock (&skirmishs_lock);
+
+  fusion_list_foreach (l, skirmishs)
+    {
+      FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+      if (skirmish->id == id)
+        return skirmish;
+    }
+
+  spin_unlock (&skirmishs_lock);
+
+  return NULL;
+}
+
+static FusionSkirmish *
+lock_skirmish (int id)
+{
+  FusionSkirmish *skirmish = lookup_skirmish (id);
+
+  if (skirmish)
+    {
+      spin_lock (&skirmish->lock);
+      spin_unlock (&skirmishs_lock);
+    }
+
+  return skirmish;
+}
+
+static void
+unlock_skirmish (FusionSkirmish *skirmish)
+{
+  spin_unlock (&skirmish->lock);
+}
diff -Naur linux-2.4.20-rc1/drivers/char/fusion/skirmish.h linux-2.4.20-rc1-fusion/drivers/char/fusion/skirmish.h
--- linux-2.4.20-rc1/drivers/char/fusion/skirmish.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/fusion/skirmish.h	2002-11-02 02:28:29.000000000 +0100
@@ -0,0 +1,40 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  convergence integrated media GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__SKIRMISH_H__
+#define __FUSION__SKIRMISH_H__
+
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_skirmish_init (void);
+void fusion_skirmish_cleanup (void);
+
+
+/* public API */
+
+int fusion_skirmish_new (int *id);
+int fusion_skirmish_prevail (int id, int fusion_id);
+int fusion_skirmish_swoop (int id, int fusion_id);
+int fusion_skirmish_dismiss (int id, int fusion_id);
+int fusion_skirmish_destroy (int id);
+
+
+/* internal functions */
+
+void fusion_skirmish_dismiss_all (int fusion_id);
+
+#endif
diff -Naur linux-2.4.20-rc1/drivers/char/fusion/types.h linux-2.4.20-rc1-fusion/drivers/char/fusion/types.h
--- linux-2.4.20-rc1/drivers/char/fusion/types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/fusion/types.h	2002-10-16 14:25:49.000000000 +0200
@@ -0,0 +1,23 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  convergence integrated media GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__TYPES_H__
+#define __FUSION__TYPES_H__
+
+typedef enum {
+  false = 0,
+  true  = !false
+} bool;
+
+#endif
diff -Naur linux-2.4.20-rc1/drivers/char/misc.c linux-2.4.20-rc1-fusion/drivers/char/misc.c
--- linux-2.4.20-rc1/drivers/char/misc.c	2002-11-01 13:32:32.000000000 +0100
+++ linux-2.4.20-rc1-fusion/drivers/char/misc.c	2002-11-02 03:11:39.000000000 +0100
@@ -77,6 +77,7 @@
 extern int tosh_init(void);
 extern int i8k_init(void);
 extern int lcd_init(void);
+extern int fusion_init(void);
 
 static int misc_read_proc(char *buf, char **start, off_t offset,
 			  int len, int *eof, void *private)
@@ -285,6 +286,9 @@
 #ifdef CONFIG_I8K
 	i8k_init();
 #endif
+#ifdef CONFIG_FUSION_DEVICE
+	fusion_init();
+#endif
 	if (devfs_register_chrdev(MISC_MAJOR,"misc",&misc_fops)) {
 		printk("unable to get major %d for misc devices\n",
 		       MISC_MAJOR);
diff -Naur linux-2.4.20-rc1/include/linux/fusion.h linux-2.4.20-rc1-fusion/include/linux/fusion.h
--- linux-2.4.20-rc1/include/linux/fusion.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-rc1-fusion/include/linux/fusion.h	2002-11-02 02:38:50.000000000 +0100
@@ -0,0 +1,27 @@
+#ifndef __LINUX__FUSION_H__
+#define __LINUX__FUSION_H__
+
+#include <asm/ioctl.h>
+#include <asm/types.h>
+
+#define FUSION_GET_ID                   _IOR('F', 0x00, sizeof(int))
+
+#define FUSION_REF_NEW                  _IOW('F', 0x10, sizeof(int))
+#define FUSION_REF_UP                   _IOW('F', 0x11, sizeof(int))
+#define FUSION_REF_UP_GLOBAL            _IOW('F', 0x12, sizeof(int))
+#define FUSION_REF_DOWN                 _IOW('F', 0x13, sizeof(int))
+#define FUSION_REF_DOWN_GLOBAL          _IOW('F', 0x14, sizeof(int))
+#define FUSION_REF_ZERO_LOCK            _IOW('F', 0x15, sizeof(int))
+#define FUSION_REF_ZERO_TRYLOCK         _IOW('F', 0x16, sizeof(int))
+#define FUSION_REF_UNLOCK               _IOW('F', 0x17, sizeof(int))
+#define FUSION_REF_STAT                 _IOR('F', 0x18, sizeof(int))
+#define FUSION_REF_DESTROY              _IOW('F', 0x19, sizeof(int))
+
+#define FUSION_SKIRMISH_NEW             _IOW('F', 0x20, sizeof(int))
+#define FUSION_SKIRMISH_PREVAIL         _IOW('F', 0x21, sizeof(int))
+#define FUSION_SKIRMISH_SWOOP           _IOW('F', 0x22, sizeof(int))
+#define FUSION_SKIRMISH_DISMISS         _IOW('F', 0x23, sizeof(int))
+#define FUSION_SKIRMISH_DESTROY         _IOW('F', 0x24, sizeof(int))
+
+#endif
+
diff -Naur linux-2.4.20-rc1/include/linux/miscdevice.h linux-2.4.20-rc1-fusion/include/linux/miscdevice.h
--- linux-2.4.20-rc1/include/linux/miscdevice.h	2002-11-01 13:33:02.000000000 +0100
+++ linux-2.4.20-rc1-fusion/include/linux/miscdevice.h	2002-11-02 03:11:39.000000000 +0100
@@ -14,6 +14,7 @@
 #define PC110PAD_MINOR 9
 #define ADB_MOUSE_MINOR 10
 #define MK712_MINOR 15			/* MK712 touch screen */
+#define FUSION_MINOR		 23	/* Fusion Device      */
 #define WATCHDOG_MINOR		130	/* Watchdog timer     */
 #define TEMP_MINOR		131	/* Temperature Sensor */
 #define RTC_MINOR 135
